/* SQL SERVER */

/* MESMA SINTAXE PARA CRIAÇAO DE DATABASE E TABELA */
/* MESMO DELIMITER ; */

/* EXECUTA DE FORMA ASSINCRONA, SEM ORDEM, PRIORIZA FACILIDADE DE EXECUÇAO */
/* GO (DELIMITER) - SERVE PARA QUEBRAR QUERY POR QUERY FAZENDO COM QUE SEJA EXECUTADO NA ORDEM */

/* MDF - ARMAZENA DADOS - BOA PRATICA É DEIXAR APENAS PARA OS DADOS DO SISTEMA */
/* LDF - REGISTRA AS TRANSAÇOES, COMANDOS EXECUTADOS NO BANCO, POSSIBILITA RETORNAR EM CASO DE FALHA */
/* NDF - ARMAZENA DADOS - PARTICIONA OS BANCOS */

/* ORGANIZANDO FISICAMENTE E LOGICAMENTE UM BANCO DE DADOS */

/* 1- CRIAR O BANCO PARA OS SETORES DE MKT E RH - CRIAR BANCO DE DADOS
   2- CRIAR UM ARQUIVO GERAL - IR CRIANDO OS GRUPOD E ARQUIVOS E ADIC
   3- DEIXA O MDF APENAS COM O DICIONARIO DE DADOS 
   4- CRIAR 2 GRUPOS DE ARQUIVOS (PRIMARY - MDF) */
   
/* NO SQLSERVER DA PRA CRIAR TABELA GRAFICAMENTE */
/* FILESTREAM - ARMAZENAMENTO DE DOCUMENTO EXTERNO EM TABELA */
/* POR PADRAO SE NAO ESPECIFICAR DESTINO DA TABELA, ELA VAI PRO GRUPO DE ARQUIVOS PADRONIZADO NA CRIAÇAO DO BANCO, NO CASO GERAL */
/* UMA TABELA NAO PODE SER DIRECIONADA PARA UM ARQUIVO EM SI, SOMENTE PARA UM GRUPO DE ARQUIVOS */

CREATE TABLE ALUNO(
	IDALUNO INT PRIMARY KEY IDENTITY /* IDENTITY (1,1) [PADRAO] = AUTO_INCREMENT */
	SEXO CHAR(1) NOT NULL /* NAO POSSUI ENUM */
	EMAIL VARCHAR (30) UNIQUE, /* UNIQUE É UMA CONSTRAINT */
);

/* RECOMENDA-SE CRIRAR CONSTRAIN/CHAVE POR FORA DA CRIAÇAO DA TABELA PARA NOMEAR */

/* ALTERNATIVA DO ENUM - CRIA-SE CONSTRAINT */
/* CONSTRAINT DO TIPO CHECK PARA VALIDAÇAO */

ALTER TABLE ALUNO
ADD CONSTRAINT CK_SEXO CHECK (SEXO IN('M','F'))
GO

/* RELEMBRANDO CRIANDO A FK POR FORA - MESMO DO MYSQL*/

ALTER TABLE ENDERECO ADD CONSTRAINT FK_ENDERECO_ALUNO
FOREIGN KEY (ID_ALUNO) REFERENCES ALUNO (IDALUNO) 
GO

/* PROCEDURES JA CRIADAS PARA COMANDOS DE DESCRIÇAO - DESC/SHOW TABLE */
/* DESC TABLE = SP_COLUMNS 'TABELA' GO / SP_HELP 'TABELA' GO (MAIS DETALHADO) */
/* AO DAR ERRO NOS INSERTS, O ID COTINUA CONTANDO DO PK */

/* FUNÇAO IFNULL DO MYSQL NO SQLSERVER É  !!!!ISNULL(COLUNA,STRING)!!!! */
SELECT	A.NOME,
		E.UF, 
		ISNULL(T.TIPO,'N/P') AS TIPO, 
		ISNULL(T.NUMERO,'NÃO POSSUI') AS NUMERO 
FROM ALUNO A
LEFT JOIN ENDERECO E
ON E.ID_ALUNO = A.IDALUNO
LEFT JOIN TELEFONE T
ON T.ID_ALUNO = A.IDALUNO
GO

/* MANIPULANDO DATA */

GETDATE() /* TRAZ DIA E HORA ATUAL - PODE USAR DENTRO DE DATEDIFF COMO PARAMETRO PARA SELECT */
		  /* DA PRA TRAZER UM UNICO ELEMENTO DA DATA EX: SELECT NOME, DAY('COLUNA COM DATA') FROM ALUNO / RETORNA INT */

DATEDIFF() /* MOSTRA DIFERENÇA ENTRE DUAS DATAS - RETORNA VALOR INTEIRO */
		   /* ('DAY'/'MONTH'/'YEAR','COLUNA 1 - COM DATA','COL UNA 2 - OUTRA DATA')) */ 
		   /* RETORNO INT, LOGO DA PRA FAZER OPERAÇAO MATEMATICA */

DATENAME(MONTH,'COLUNA COM DATA') /* TRAZ UMA STRING COM O NOME DO MES */
DATENAME(WEEKDAY,'COLUNA COM DATA') /* TRAZ UMA STRING COM NOME DO DIA */

DATEPART(MONTH,'COLUNA COM DATA') /* TRAZ UM INT COM O NUMERO DO MES */

DATEADD(DAY/MONTH/YEAR,'QUANTO/BASEIA NO PRIMEIRO','COLUNA COM A DATA')
		/* RETORNA UMA DATA */
		
/* DAY/MONTH/YEAR('COLUNA COM DATE') FUNCIONA PARA ESPECIFICAR APENAS UM */
/* EXEMPLO DO CASO ACIMA COM CAST */

SELECT	NOME,
		CAST(DAY(DATA_NASC) AS varchar(2)) + ' / ' + CAST(MONTH(DATA_NASC) AS varchar(2)) + ' / ' + CAST(YEAR(DATA_NASC) AS varchar(4))
FROM ALUNO
GO

/* SQLSERVER TEM CONVERSAO AUTOMATICA - EXEMPLO: SELECT 1 + '1', PADRAO STRING -> INT */

/* CAST PARA CONVERTER UM DADO - CONVERSAO EXPLICITA */
SELECT CAST('1' AS INT) + CAST('1' AS INT) GO

/* CHARINDEX - LOCALIZA A POSIÇAO DA LETRA PROCURADA POR INDEX */
/* RETORNA UM INTEIRO PARA OPERAÇAO */

SELECT NOME, CHARINDEX('LETRA','CAMPO','A PARTIR DE QUAL LETRA')

/* BULK INSERT - INSERINDO DADOS DE OUTRO ARQUIVO, EX ABAIXO TXT */
/* OS ENTERS A MAIS ABAIXO DOS DADOS TAMBEM VAI CONTAR PARA O INSERT */

BULK INSERT 'TABELA PRA ENTRADA' /* DEVE ATENTAR AOS TIPOS DOS CAMPOS */
FROM 'CAMINHO DO ARQUIVO COM EXTENÇAO'
WITH /* ESPECIFICANDO DENTRO DO ARQUIVO */
(
	FIRSTROW = 2, /*COMEÇA DE QUE LINHA */
	DATAFILETYPE = 'char',
	FIELDTERMINATOR = '\t' /* no caso TAB, o que separa os campos nas linhas do doc */
	ROWTERMINATOR = '\n' /*no caso ENTER, o que separa as linhas nas colunas */
)
GO


/* TRIGGER NO SQLSERVER */
/* BOA PRATICA - AO ATRIBUIR VALOR A UMA VARIAVEL PROVINDA DE OUTRA TABELA = SELECT se for DE FUNÇAO OU LITERAL = SET */
/* TRIGGER DE AUDITORIA DE MUDANÇA DE PRECO EM UMA COLUNA ESPECIFICA */

CREATE TRIGGER TRG_MUDA_PRECO
ON PRODUTOS
FOR UPDATE
AS
	IF UPDATE (PRECO)
	BEGIN
		DECLARE @PRODUTO VARCHAR (50)
		DECLARE @CATEGORIA VARCHAR (30)
		DECLARE @PRECOANTIGO NUMERIC (10,2)
		DECLARE @PRECONOVO NUMERIC (10,2)
		DECLARE @DATA DATETIME
		DECLARE @USUARIO VARCHAR (30)
		DECLARE @MENSAGEM VARCHAR (100)

		SELECT @PRODUTO = NOME FROM INSERTED
		SELECT @CATEGORIA = CATEGORIA FROM INSERTED
		SELECT @PRECOANTIGO = PRECO FROM DELETED
		SELECT @PRECONOVO = PRECO FROM INSERTED
		
		SET @DATA = GETDATE()
		SET @USUARIO = SUSER_NAME()
		SET @MENSAGEM = 'VALOR INSERIDO PELA TRIGGER TRG_MUDA_PRECO'

		INSERT INTO AUD_PRODUTO (PRODUTO, CATEGORIA, PRECOANTIGO, PRECONOVO, DATA, USUARIO, MENSAGEM) VALUES 
		(@PRODUTO, @CATEGORIA, @PRECOANTIGO, @PRECONOVO, @DATA, @USUARIO, @MENSAGEM)
	END
END
GO

/* ABREVIANDO COM INSERT + SELECT (NO LUGAR DO VALUES) */

CREATE TRIGGER TRG_MUDA_PRECO
ON PRODUTOS
FOR UPDATE
AS
	IF UPDATE (PRECO)
	BEGIN
		INSERT INTO AUD_PRODUTO (PRODUTO, CATEGORIA, PRECOANTIGO, PRECONOVO, DATA, USUARIO, MENSAGEM)
		SELECT I.PRODUTO, I.CATEGORIA, D.PRECOA, I.PRECO, GETDATE(), SUSER_NAME(), 'ATT W/ TRG_MUDA_PRECO'
		FROM INSERTED I
		INNER JOIN DELETED D /* NECESSARIO PARA ATUALIZAÇAO EM MASSA */
		ON I.PRODUTO = D.PRODUTO
	END
END
GO

/* TRIGGER COM RANGE PARA AUDITORIA */

CREATE TRIGGER TRG_VER_SAL
ON FUNCIONARIO
FOR INSERT,UPDATE
AS
	DECLARE @MINSAL MONEY
	DECLARE @MAXSAL MONEY
	DECLARE @NOVOSAL MONEY

	SELECT @MINSAL = MINSAL, @MAXSAL = MAXSAL FROM RANGE_SAL
	SELECT @NOVOSAL = SALARIO
	FROM inserted

	IF (@NOVOSAL > @MAXSAL)
	BEGIN
		PRINT 'SALARIO ACIMA DO TETO'
		ROLLBACK TRANSACTION /* ANULA O INSERT/UPDATE NEM CHEGA A EXISTIR */
	END
	IF (@NOVOSAL < @MINSAL)
	BEGIN
		PRINT 'SALARIO ABAIXO DO TETO'
		ROLLBACK TRANSACTION
	END
GO

/* RETORNA TODA A TRIGGER */

SP_HELPTEXT 'NOME DA TRIGGER'
GO

/* MONEY = NUMERIC COM 2 CASAS APOS VIRGULA */

/* SELECT COM INSERT FUNCIONA, APENAS SUBSTITUIR NO LUGAR DO VALUES E REFERENCIAR AS TABELAS, SEMPRE NA ORDEM DEFINIDA DOS CAMPOS DO INSERT */

INSERT INTO 'TABELA' ('CAMPO1','CAMPO2') 
SELECT 1 + 1, 2 + 2
GO

/* CRIANDO PROCEDURE */
/* ESTATICA - SEM PARAMETRO */

CREATE PROC SOMA
as
	SELECT 10 + 10 AS SOMA
GO

/* DINAMICA - COM PARAMETROS */

CREATE PROC SOMA @NUM1('PARAMETRO FORMA DE VARIAVEL') INT, @NUM2 INT
as
	SELECT @NUM1 + @NUM2
GO

/* APAGANDO */

DROP PROC 'NOME DA PROC'
GO

/* PARAMETRO DE OUTPUT */
/* CRIADO POR MIM, SEM USAR CLAUSULA OUTPUT */
/* DECLARANDO UMA VARIAVEL PRO CONTADOR E PRINTANDO APOS */

CREATE PROC R_CONT @TIPO1 CHAR(3)
AS
	DECLARE @CONT INT
	
	SELECT @CONT = COUNT(*)
	FROM TELEFONE
	WHERE TIPO = @TIPO1
	
	PRINT 'Possui ' + CAST(@CONT AS VARCHAR (3)) + ' números cadastrados de tipo ' + @TIPO1 + '.'

GO

/* UTILIZANDO CLAUSULA OUTPUT SEM DECLRAR O CONTADOR */

CREATE PROC R_CONT @TIPO1 CHAR(3), @CONT INT OUTPUT
AS	
	SELECT @CONT = COUNT(*)
	FROM TELEFONE
	WHERE TIPO = @TIPO1

GO

/* OUTPUT RETORNA O VALOR(PRECISA DE UMA VARIAVEL EXTERNA PARA RECEBER E MANIPULAR) */

DECLARE @SAIDA INT
EXEC R_CONT CEL, @SAIDA OUTPUT /* OUTPUT OBRIGATORIO PARA RETONRNO */
SELECT @SAIDA
GO


/* desafio - procedure de cadastro */

CREATE PROC CADASTRO 
@NOME VARCHAR (30), 
@IDADE CHAR(2),
@SEXO CHAR(1), 
@NASC DATE, 
@TIPO CHAR(3), 
@DDD CHAR (2), 
@NUMERO VARCHAR(30)
AS

DECLARE @ID_ALUNO INT

INSERT INTO ALUNO (NOME, IDADE, SEXO, DATA_NASC) 
VALUES (@NOME, @IDADE, @SEXO, @NASC)

SELECT @ID_ALUNO = @@IDENTITY /* GUARDA O ULTIMO PK */

INSERT INTO TELEFONE (TIPO, DDD, NUMERO, ID_ALUNO)
VALUES (@TIPO, @DDD, @NUMERO, @ID_ALUNO)

PRINT 'Cadastrado com sucesso!'

END

/* BLOCO ANONIMO - UM BLOCO DE TSQL QUALQUER, NAO NOMEADO */
/* BLOCO NOMEADO - BLOCO QUE FICA SALVO, TRIGGER, PROC */
/* EXERCICIO SIMPLES IF/ESLE */

CREATE PROC T_F @VALOR INT

IF @VALOR = 5
	THEN PRINT 'Verdadeiro'
ELSE
	PRINT 'Falso'
END
GO

/* WHILE */
/* SIMPLES CONTADOR DE 1 A 15 */

DECLARE 
	@CONT INT = 0
BEGIN
	WHILE (@CONT <15)
	BEGIN
		PRINT @CONT
		SET @CONT = @CONT +1
	END
END
GO






   